<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- MUST HAVE: Responsive Viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SENTERNET CHESS ARENA</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom Styles for the Chess Board and Game */
        /* Use Inter font as default */
        html, body {
            font-family: 'Inter', sans-serif;
        }

        /* Chessboard.js CSS must be loaded */
        @import url("https://unpkg.com/chessboardjs@0.3.0/dist/chessboard.min.css");

        /* Center the board container and make it look clean */
        #board-container {
            max-width: 450px; /* Max size for desktop view */
            width: 95vw; /* Fluid width for mobile */
            margin: auto;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
            border-radius: 12px;
            overflow: hidden;
        }

        /* Custom styling for the pieces to override default colors/look if needed */
        .white-player-info, .black-player-info {
            transition: all 0.3s ease-in-out;
            border-radius: 8px;
            padding: 8px 12px;
            margin-bottom: 4px;
        }

        .active-turn {
            background-color: #fca5a5; /* Light red/rose tone for active turn */
            transform: scale(1.03);
            font-weight: 700;
        }

        /* Styling for the Winner Modal (Pop Effect) */
        #winner-modal {
            transition: opacity 0.3s ease-in-out;
        }

        .winner-card {
            animation: pop-in 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards;
            background-image: linear-gradient(135deg, #fef3c7, #fde68a);
        }

        @keyframes pop-in {
            0% { transform: scale(0.5) rotateY(90deg); opacity: 0; }
            80% { transform: scale(1.05) rotateY(-5deg); opacity: 1; }
            100% { transform: scale(1) rotateY(0deg); opacity: 1; }
        }

        /* Ensure piece sizing is correct on fluid layouts, though chessboard.js handles much of this */
        .square-55d63 {
            position: relative;
        }

        /* Button styling for a "pop" effect on interaction */
        .game-btn {
            @apply shadow-md transition duration-200 ease-in-out transform hover:scale-[1.02] active:scale-[0.98];
        }

        /* Mobile specific adjustments */
        @media (max-width: 640px) {
            #board-container {
                max-width: 100%;
                width: 100vw;
                border-radius: 0;
            }
        }

    </style>
</head>
<body class="bg-gray-100 min-h-screen p-4 flex flex-col items-center">

    <!-- Header -->
    <header class="w-full max-w-lg mb-6 text-center">
        <h1 class="text-3xl font-extrabold text-red-700">SENTERNET CHESS ARENA</h1>
        <p class="text-sm text-gray-500">Play against the Bot or challenge a Friend.</p>
    </header>

    <!-- Game Information and Controls -->
    <div id="game-info" class="w-full max-w-lg mb-4 p-4 bg-white rounded-xl shadow-lg">
        <div class="flex justify-between items-center mb-2">
            <!-- White Player Info -->
            <div id="white-player-info" class="white-player-info bg-gray-50 text-gray-800 flex-1 mr-2 text-center">
                White: <span id="white-player-name" class="font-semibold"></span>
            </div>
            <!-- Black Player Info -->
            <div id="black-player-info" class="black-player-info bg-gray-50 text-gray-800 flex-1 ml-2 text-center">
                Black: <span id="black-player-name" class="font-semibold"></span>
            </div>
        </div>
        <div class="text-center">
            <p id="game-status" class="text-lg font-bold text-gray-600 mb-3"></p>
            <div class="flex justify-center space-x-2">
                <button id="reset-button" class="game-btn bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-full font-medium" onclick="showSetupModal()">
                    New Game Setup
                </button>
            </div>
        </div>
    </div>

    <!-- Chess Board Container -->
    <div id="board-container" class="mb-6">
        <div id="board" style="width: 100%;"></div>
    </div>

    <!-- Setup Modal -->
    <div id="setup-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center p-4 hidden">
        <div class="bg-white p-6 md:p-8 rounded-xl shadow-2xl w-full max-w-md transform transition-all">
            <h2 class="text-2xl font-bold text-red-600 mb-6 text-center">Start New Game</h2>

            <div class="mb-6">
                <label class="block text-gray-700 text-sm font-bold mb-2">Game Mode</label>
                <select id="game-mode-select" class="shadow appearance-none border rounded w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:shadow-outline transition duration-150" onchange="togglePlayerInputs()">
                    <option value="PvB">Player vs. Bot</option>
                    <option value="PvP">Player vs. Friend</option>
                </select>
            </div>

            <div class="mb-6">
                <label class="block text-gray-700 text-sm font-bold mb-2">Your Name (White)</label>
                <input id="player-1-name" type="text" placeholder="Enter your name" class="shadow appearance-none border rounded w-full py-3 px-4 text-gray-700 leading-tight focus:ring-2 focus:ring-red-500 focus:outline-none focus:shadow-outline transition duration-150" value="Senthilkumar">
            </div>

            <!-- Player 2 Name - Hidden in PvB mode -->
            <div id="player-2-input-group" class="mb-6 hidden">
                <label class="block text-gray-700 text-sm font-bold mb-2">Friend's Name (Black)</label>
                <input id="player-2-name" type="text" placeholder="Enter friend's name" class="shadow appearance-none border rounded w-full py-3 px-4 text-gray-700 leading-tight focus:ring-2 focus:ring-red-500 focus:outline-none focus:shadow-outline transition duration-150" value="Friend">
            </div>

            <div id="color-select-group" class="mb-6">
                <label class="block text-gray-700 text-sm font-bold mb-2">Choose Your Color</label>
                <div class="flex space-x-4">
                    <button id="color-white" class="flex-1 py-3 px-4 border-2 border-red-500 rounded-lg text-red-600 font-semibold bg-red-100 hover:bg-red-200 focus:outline-none transition duration-150" data-color="white">
                        White
                    </button>
                    <button id="color-black" class="flex-1 py-3 px-4 border-2 border-gray-700 rounded-lg text-gray-800 font-semibold hover:bg-gray-100 focus:outline-none transition duration-150" data-color="black">
                        Black
                    </button>
                </div>
            </div>

            <button id="start-game-button" class="game-btn w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg focus:outline-none focus:shadow-outline transition duration-200" onclick="startGame()">
                Start Game!
            </button>
        </div>
    </div>

    <!-- Winner Modal (Full Screen) -->
    <div id="winner-modal" class="fixed inset-0 bg-black bg-opacity-80 z-50 flex items-center justify-center p-4 hidden opacity-0" onclick="hideWinnerModal()">
        <div class="winner-card p-10 md:p-16 rounded-3xl shadow-2xl text-center text-gray-900" style="min-width: 80vw; max-width: 800px;" onclick="event.stopPropagation()">
            <h1 class="text-4xl md:text-6xl font-black mb-4 animate-pulse">GAME OVER!</h1>
            <p id="winner-text" class="text-5xl md:text-8xl font-extrabold mb-6 text-yellow-700 drop-shadow-lg">
                <!-- Winner name will be injected here -->
            </p>
            <p id="winning-condition" class="text-xl md:text-3xl font-semibold text-yellow-800 mb-8"></p>
            <button class="game-btn bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-8 rounded-full text-lg" onclick="hideWinnerModal(); showSetupModal();">
                Play Another Round!
            </button>
        </div>
    </div>

    <!-- Footer for SENTERNET TECHNOLOGIES -->
    <footer class="mt-8 w-full max-w-lg text-center p-4 text-xs text-gray-500 border-t border-gray-300">
        <p>A Project by SENTERNET TECHNOLOGIES | Location: Aranthangi</p>
        <p>Contact: +91 81900 38085 | Mail: senternettechnologies@gmail.com</p>
    </footer>

    <!-- Load JavaScript Libraries -->
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <script src="https://unpkg.com/chessboardjs@0.3.0/dist/chessboard.min.js"></script>
    <script src="https://unpkg.com/chess.js@1.0.0-beta.8/dist/chess.js"></script>

    <script>
        // Global variables for the game state
        let game = null;
        let board = null;
        let players = {
            w: { name: 'Player 1', isBot: false },
            b: { name: 'Player 2', isBot: false }
        };
        let playerColor = 'w'; // The color the human player is controlling ('w' or 'b')
        const BOT_NAME = 'ChessBot 9000';
        const AI_DEPTH = 3; // Depth for the simple AI

        // Piece values for simple evaluation
        const PIECE_VALUES = {
            'p': 100, 'n': 320, 'b': 330, 'r': 500, 'q': 900, 'k': 20000
        };

        // Utility to get the current user color
        const getCurrentPlayerColor = () => game.turn();

        // --- UI HANDLERS ---

        /**
         * Toggles the visibility of Player 2 input and color selector based on game mode.
         */
        function togglePlayerInputs() {
            const mode = document.getElementById('game-mode-select').value;
            const p2Group = document.getElementById('player-2-input-group');
            const colorGroup = document.getElementById('color-select-group');

            if (mode === 'PvP') {
                p2Group.classList.remove('hidden');
                colorGroup.classList.add('hidden');
                document.getElementById('player-2-name').value = 'Friend';
            } else {
                p2Group.classList.add('hidden');
                colorGroup.classList.remove('hidden');
                document.getElementById('player-2-name').value = BOT_NAME;
            }
        }

        /**
         * Handles the selection of player color in PvB mode.
         * @param {string} color - 'white' or 'black'
         */
        function selectColor(color) {
            playerColor = color === 'white' ? 'w' : 'b';
            const whiteBtn = document.getElementById('color-white');
            const blackBtn = document.getElementById('color-black');

            // Reset styles
            whiteBtn.classList.remove('bg-red-400', 'border-4');
            blackBtn.classList.remove('bg-red-400', 'border-4');
            whiteBtn.classList.add('bg-red-100', 'border-2');
            blackBtn.classList.add('hover:bg-gray-100', 'border-2');

            // Apply selected style
            if (color === 'white') {
                whiteBtn.classList.add('bg-red-400', 'border-4');
                whiteBtn.classList.remove('bg-red-100', 'border-2');
            } else {
                blackBtn.classList.add('bg-red-400', 'border-4');
                blackBtn.classList.remove('hover:bg-gray-100', 'border-2');
            }
        }

        /**
         * Initializes and starts the game based on the modal configuration.
         */
        function startGame() {
            const mode = document.getElementById('game-mode-select').value;
            const p1Name = document.getElementById('player-1-name').value || 'Player 1';
            const p2Name = document.getElementById('player-2-name').value || (mode === 'PvB' ? BOT_NAME : 'Player 2');

            // Reset and initialize the Chess game instance
            game = new Chess();
            
            // Set player objects
            if (mode === 'PvP') {
                players.w = { name: p1Name, isBot: false };
                players.b = { name: p2Name, isBot: false };
                playerColor = 'both'; // Both sides are human controlled
            } else { // PvB
                if (playerColor === 'w') {
                    players.w = { name: p1Name, isBot: false };
                    players.b = { name: BOT_NAME, isBot: true };
                } else {
                    players.w = { name: BOT_NAME, isBot: true };
                    players.b = { name: p1Name, isBot: false };
                }
            }

            // Update UI with player names
            document.getElementById('white-player-name').textContent = players.w.name + (players.w.isBot ? ' (BOT)' : '');
            document.getElementById('black-player-name').textContent = players.b.name + (players.b.isBot ? ' (BOT)' : '');

            // Hide modal and update status
            document.getElementById('setup-modal').classList.add('hidden');
            updateGameStatus();
            board.position(game.fen());

            // Check if the bot starts first
            if (mode === 'PvB' && playerColor === 'b') {
                setTimeout(makeBotMove, 500); // Give a slight delay
            }
        }

        /**
         * Displays the setup modal.
         */
        function showSetupModal() {
            document.getElementById('setup-modal').classList.remove('hidden');
            // Ensure initial toggle state is correct
            togglePlayerInputs();
        }

        /**
         * Updates the current turn indicator and game status message.
         */
        function updateGameStatus() {
            const turn = getCurrentPlayerColor(); // 'w' or 'b'
            const statusText = document.getElementById('game-status');
            const whiteInfo = document.getElementById('white-player-info');
            const blackInfo = document.getElementById('black-player-info');

            // Reset indicators
            whiteInfo.classList.remove('active-turn');
            blackInfo.classList.remove('active-turn');

            if (game.isGameOver()) {
                let condition = '';
                if (game.isCheckmate()) {
                    condition = 'Checkmate';
                } else if (game.isDraw()) {
                    condition = 'Draw';
                    if (game.isStalemate()) condition += ' (Stalemate)';
                    else if (game.isThreefoldRepetition()) condition += ' (Threefold Repetition)';
                    else if (game.isInsufficientMaterial()) condition += ' (Insufficient Material)';
                    else condition += ' (50-move rule)';
                }

                displayWinner(condition);
                statusText.textContent = `Game Over: ${condition}`;

            } else {
                const currentPlayer = turn === 'w' ? players.w.name : players.b.name;
                statusText.textContent = `Turn: ${currentPlayer} (${turn === 'w' ? 'White' : 'Black'})`;

                // Set active turn indicator
                if (turn === 'w') {
                    whiteInfo.classList.add('active-turn');
                } else {
                    blackInfo.classList.add('active-turn');
                }

                if (game.inCheck()) {
                    statusText.textContent += ' (CHECK!)';
                    statusText.classList.add('text-red-500');
                } else {
                    statusText.classList.remove('text-red-500');
                }

                // Check for bot turn
                if (players[turn].isBot) {
                    // statusText.textContent += ' (BOT THINKING...)';
                    setTimeout(makeBotMove, 1000); // Small delay for effect
                }
            }
        }

        /**
         * Displays the full-screen winner modal with pop effect.
         * @param {string} condition - The reason the game ended.
         */
        function displayWinner(condition) {
            const modal = document.getElementById('winner-modal');
            const winnerText = document.getElementById('winner-text');
            const conditionText = document.getElementById('winning-condition');

            let winnerName = 'NO WINNER';

            if (game.isCheckmate()) {
                const winningColor = getCurrentPlayerColor() === 'w' ? 'b' : 'w';
                winnerName = players[winningColor].name;
                winnerText.textContent = `${winnerName} WINS!`;
                conditionText.textContent = `by ${condition}`;
            } else if (game.isDraw()) {
                winnerText.textContent = 'GAME DRAW!';
                conditionText.textContent = condition;
            }

            modal.classList.remove('hidden', 'opacity-0');
            modal.classList.add('opacity-100');
        }

        /**
         * Hides the winner modal.
         */
        function hideWinnerModal() {
            const modal = document.getElementById('winner-modal');
            modal.classList.add('opacity-0');
            setTimeout(() => {
                modal.classList.add('hidden');
            }, 300); // Match transition duration
        }

        // --- CHESS LOGIC HANDLERS ---

        /**
         * Called when a piece is dropped on the board.
         * @param {string} source - Square the piece started from.
         * @param {string} target - Square the piece ended on.
         * @param {string} piece - The piece moved.
         * @param {string} newPos - New FEN position.
         * @param {string} oldPos - Old FEN position.
         * @param {string} orientation - Board orientation.
         * @returns {string} 'snapback' if move is illegal.
         */
        function onDrop(source, target) {
            // Check if it's the human player's turn to move
            const turn = getCurrentPlayerColor();
            const isBotTurn = players[turn].isBot;
            const isHumanTurn = (playerColor === 'both' || playerColor === turn) && !isBotTurn;

            if (!isHumanTurn) {
                return 'snapback';
            }

            // Check for promotion, default to Queen ('q') for simplicity
            let move = {
                from: source,
                to: target,
                promotion: 'q'
            };

            // Attempt to move the piece
            let result = game.move(move);

            // Illegal move
            if (result === null) {
                return 'snapback';
            }

            // Move was legal
            updateGameStatus();
        }

        /**
         * Called when the square is clicked or a piece is picked up.
         * @param {string} square - The square identifier (e.g., 'a1').
         * @param {string} piece - The piece on the square (e.g., 'wP').
         * @returns {boolean} False to prevent drag, true to allow.
         */
        function onDragStart(source, piece, position, orientation) {
            const turn = getCurrentPlayerColor();
            const isBotTurn = players[turn].isBot;
            const isHumanTurn = (playerColor === 'both' || playerColor === turn) && !isBotTurn;

            // Do not pick up pieces if the game is over or it's not the human's turn.
            if (game.isGameOver() || !isHumanTurn || piece.search(turn) === -1) {
                return false;
            }
        }

        /**
         * Updates the board position to the current FEN when a snap animation finishes.
         */
        function onSnapEnd() {
            board.position(game.fen());
        }

        // --- BOT (AI) LOGIC ---

        /**
         * Evaluates the current board position based on material.
         * Positive value favors white, negative favors black.
         * @returns {number} The evaluation score.
         */
        function evaluateBoard() {
            let score = 0;
            const boardData = game.board();

            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const piece = boardData[i][j];
                    if (piece) {
                        const value = PIECE_VALUES[piece.type];
                        if (piece.color === 'w') {
                            score += value;
                        } else {
                            score -= value;
                        }
                    }
                }
            }
            return score;
        }

        /**
         * Picks the best move for the bot using a simple greedy material gain strategy.
         */
        function findBestMove() {
            const possibleMoves = game.moves({ verbose: true });
            let bestMove = null;
            let bestScore = -Infinity;
            const turn = game.turn(); // Bot's color

            // Bot wants to maximize its own score (if turn === 'w') or minimize (if turn === 'b')
            const isMaximizingPlayer = turn === 'w';

            // If no moves, something is wrong, but just return null
            if (possibleMoves.length === 0) return null;

            // Simple move search (Greedy/Evaluation based)
            for (let i = 0; i < possibleMoves.length; i++) {
                const move = possibleMoves[i];
                game.move(move);

                // Evaluate the board *after* the move
                let currentScore = evaluateBoard();

                // If maximizing (White), we want the highest score
                // If minimizing (Black), we want the lowest score (equivalent to maximizing -score)
                if (turn === 'b') {
                    currentScore = -currentScore; // Black reverses the score for simplicity
                }

                game.undo(); // Undo the move to restore the board

                // Update best move
                if (currentScore > bestScore) {
                    bestScore = currentScore;
                    bestMove = move;
                }
            }

            // Fallback: If all moves have the same score (0 material gain), choose a random one
            if (bestMove === null) {
                 const randomIndex = Math.floor(Math.random() * possibleMoves.length);
                 bestMove = possibleMoves[randomIndex];
            }

            // Add some randomness to prevent predictable play, but only if the best move isn't a significant capture
            if (Math.random() < 0.2 && possibleMoves.length > 1 && bestScore <= 100) {
                // 20% chance to pick a different random move if no major material gain is found
                const randomIndex = Math.floor(Math.random() * possibleMoves.length);
                return possibleMoves[randomIndex];
            }

            return bestMove;
        }

        /**
         * Executes the bot's move and updates the board.
         */
        function makeBotMove() {
            if (game.isGameOver()) return;

            const move = findBestMove();
            if (move) {
                game.move(move);
                board.position(game.fen(), false); // false = don't animate (or set to true for smooth bot movement)
                updateGameStatus();
            }
        }


        // --- INITIALIZATION ---

        window.onload = function() {
            // Initial setup for color buttons
            document.getElementById('color-white').onclick = () => selectColor('white');
            document.getElementById('color-black').onclick = () => selectColor('black');
            selectColor('white'); // Default selection

            // Configuration for the chessboard
            const config = {
                draggable: true,
                position: 'start',
                onDragStart: onDragStart,
                onDrop: onDrop,
                onSnapEnd: onSnapEnd
            };

            // Initialize the board
            board = Chessboard('board', config);

            // Initial game setup
            showSetupModal();

            // Set up responsiveness for the board size
            $(window).on('resize', function() {
                board.resize();
            });

            // Run initial toggle for PvB default
            togglePlayerInputs();
        };

    </script>
</body>
</html>

